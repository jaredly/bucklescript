
    
<!doctype html>
<meta charset=utf8>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel=stylesheet href='../styles.css'>
<script defer src='../script.js'></script>
<title>List</title>
<body>
<script>window.relativeToRoot=".."</script>
<script defer src="../block-script.js"></script>
<div id='error-message'>
  ⚠️ Oops! This page doesn't appear to define a <span>type</span> called <code>_</code>.
</div>

    <script>window.shouldCheckHashes=true</script>
    <div class='container'>
    
    <div class='sidebar-wrapper'>
    <div class='sidebar-expander'>Show navigation</div>
    <div class='sidebar'>
      <a href="../search.html" style="display: block; padding: 0 8px;">Search</a>
      <a href="../playground.html" style="display: block; padding: 0 8px;">Playground</a>
      <div class='docs-listing'><a href="../docson/index.html">docson</a>
<a href="../fonts/LICENSE.html">LICENSE</a>
<a href="../index.html">docs</a>
<a href="../slides/Buckle_meetup.html">Buckle_meetup</a>
<a href="../slides/Haskell_meetup.html">Haskell_meetup</a>
<a href="../slides/preview/CONTRIBUTING.html">CONTRIBUTING</a>
<a href="../slides/preview/reveal-js/css/theme/index.html">theme</a>
<a href="../slides/preview/reveal-js/plugin/markdown/example.html">example</a>
<a href="../slides/preview/reveal-js/REVEAL_JS.html">REVEAL_JS</a>
<a href="../slides/preview/Slides/bb-reveal-example/overview.html">overview</a></div>
      <div class='toc-header'>Page Contents</div>
      <div class='table-of-contents'>
      <a href="#value-length" class='level-0 value'>length</a>
<a href="#value-hd" class='level-0 value'>hd</a>
<a href="#value-tl" class='level-0 value'>tl</a>
<a href="#value-nth" class='level-0 value'>nth</a>
<a href="#value-rev" class='level-0 value'>rev</a>
<a href="#value-append" class='level-0 value'>append</a>
<a href="#value-rev_append" class='level-0 value'>rev_append</a>
<a href="#value-concat" class='level-0 value'>concat</a>
<a href="#value-flatten" class='level-0 value'>flatten</a>
<a href="#value-iter" class='level-0 value'>iter</a>
<a href="#value-iteri" class='level-0 value'>iteri</a>
<a href="#value-map" class='level-0 value'>map</a>
<a href="#value-mapi" class='level-0 value'>mapi</a>
<a href="#value-rev_map" class='level-0 value'>rev_map</a>
<a href="#value-fold_left" class='level-0 value'>fold_left</a>
<a href="#value-fold_right" class='level-0 value'>fold_right</a>
<a href="#value-iter2" class='level-0 value'>iter2</a>
<a href="#value-map2" class='level-0 value'>map2</a>
<a href="#value-rev_map2" class='level-0 value'>rev_map2</a>
<a href="#value-fold_left2" class='level-0 value'>fold_left2</a>
<a href="#value-fold_right2" class='level-0 value'>fold_right2</a>
<a href="#value-for_all" class='level-0 value'>for_all</a>
<a href="#value-exists" class='level-0 value'>exists</a>
<a href="#value-for_all2" class='level-0 value'>for_all2</a>
<a href="#value-exists2" class='level-0 value'>exists2</a>
<a href="#value-mem" class='level-0 value'>mem</a>
<a href="#value-memq" class='level-0 value'>memq</a>
<a href="#value-find" class='level-0 value'>find</a>
<a href="#value-filter" class='level-0 value'>filter</a>
<a href="#value-find_all" class='level-0 value'>find_all</a>
<a href="#value-partition" class='level-0 value'>partition</a>
<a href="#value-assoc" class='level-0 value'>assoc</a>
<a href="#value-assq" class='level-0 value'>assq</a>
<a href="#value-mem_assoc" class='level-0 value'>mem_assoc</a>
<a href="#value-mem_assq" class='level-0 value'>mem_assq</a>
<a href="#value-remove_assoc" class='level-0 value'>remove_assoc</a>
<a href="#value-remove_assq" class='level-0 value'>remove_assq</a>
<a href="#value-split" class='level-0 value'>split</a>
<a href="#value-combine" class='level-0 value'>combine</a>
<a href="#value-sort" class='level-0 value'>sort</a>
<a href="#value-stable_sort" class='level-0 value'>stable_sort</a>
<a href="#value-fast_sort" class='level-0 value'>fast_sort</a>
<a href="#value-sort_uniq" class='level-0 value'>sort_uniq</a>
<a href="#value-merge" class='level-0 value'>merge</a>
      </div>
      <div class='project-title'>Package modules</div><div class='project-listing'><a href="Js.html">Js</a>
<a href="Arg.html">Arg</a>
<a href="Array.html">Array</a>
<a href="ArrayLabels.html">ArrayLabels</a>
<a href="Bigarray.html">Bigarray</a>
<a href="Buffer.html">Buffer</a>
<a href="Bytes.html">Bytes</a>
<a href="BytesLabels.html">BytesLabels</a>
<a href="Callback.html">Callback</a>
<a href="CamlinternalFormat.html">CamlinternalFormat</a>
<a href="CamlinternalFormatBasics.html">CamlinternalFormatBasics</a>
<a href="CamlinternalLazy.html">CamlinternalLazy</a>
<a href="CamlinternalMod.html">CamlinternalMod</a>
<a href="CamlinternalOO.html">CamlinternalOO</a>
<a href="Char.html">Char</a>
<a href="Complex.html">Complex</a>
<a href="Digest.html">Digest</a>
<a href="Filename.html">Filename</a>
<a href="Format.html">Format</a>
<a href="Gc.html">Gc</a>
<a href="Genlex.html">Genlex</a>
<a href="Hashtbl.html">Hashtbl</a>
<a href="Int32.html">Int32</a>
<a href="Int64.html">Int64</a>
<a href="Lazy.html">Lazy</a>
<a href="Lexing.html">Lexing</a>
<a href="List.html">List</a>
<a href="ListLabels.html">ListLabels</a>
<a href="Map.html">Map</a>
<a href="Marshal.html">Marshal</a>
<a href="MoreLabels.html">MoreLabels</a>
<a href="Nativeint.html">Nativeint</a>
<a href="Obj.html">Obj</a>
<a href="Oo.html">Oo</a>
<a href="Parsing.html">Parsing</a>
<a href="Pervasives.html">Pervasives</a>
<a href="Printexc.html">Printexc</a>
<a href="Printf.html">Printf</a>
<a href="Queue.html">Queue</a>
<a href="Random.html">Random</a>
<a href="Scanf.html">Scanf</a>
<a href="Set.html">Set</a>
<a href="Sort.html">Sort</a>
<a href="Stack.html">Stack</a>
<a href="Std_exit.html">Std_exit</a>
<a href="StdLabels.html">StdLabels</a>
<a href="Stream.html">Stream</a>
<a href="String.html">String</a>
<a href="StringLabels.html">StringLabels</a>
<a href="Sys.html">Sys</a>
<a href="Unix.html">Unix</a>
<a href="UnixLabels.html">UnixLabels</a>
<a href="Weak.html">Weak</a>
<a href="Belt.html">Belt</a>
<a href="Belt_Array.html">Belt_Array</a>
<a href="Belt_HashMap.html">Belt_HashMap</a>
<a href="Belt_HashMapInt.html">Belt_HashMapInt</a>
<a href="Belt_HashMapString.html">Belt_HashMapString</a>
<a href="Belt_HashSet.html">Belt_HashSet</a>
<a href="Belt_HashSetInt.html">Belt_HashSetInt</a>
<a href="Belt_HashSetString.html">Belt_HashSetString</a>
<a href="Belt_Id.html">Belt_Id</a>
<a href="Belt_internalAVLset.html">Belt_internalAVLset</a>
<a href="Belt_internalAVLtree.html">Belt_internalAVLtree</a>
<a href="Belt_internalBuckets.html">Belt_internalBuckets</a>
<a href="Belt_internalBucketsType.html">Belt_internalBucketsType</a>
<a href="Belt_internalMapInt.html">Belt_internalMapInt</a>
<a href="Belt_internalMapString.html">Belt_internalMapString</a>
<a href="Belt_internalSetBuckets.html">Belt_internalSetBuckets</a>
<a href="Belt_internalSetInt.html">Belt_internalSetInt</a>
<a href="Belt_internalSetString.html">Belt_internalSetString</a>
<a href="Belt_List.html">Belt_List</a>
<a href="Belt_Map.html">Belt_Map</a>
<a href="Belt_MapDict.html">Belt_MapDict</a>
<a href="Belt_MapInt.html">Belt_MapInt</a>
<a href="Belt_MapString.html">Belt_MapString</a>
<a href="Belt_MutableMap.html">Belt_MutableMap</a>
<a href="Belt_MutableMapInt.html">Belt_MutableMapInt</a>
<a href="Belt_MutableMapString.html">Belt_MutableMapString</a>
<a href="Belt_MutableQueue.html">Belt_MutableQueue</a>
<a href="Belt_MutableSet.html">Belt_MutableSet</a>
<a href="Belt_MutableSetInt.html">Belt_MutableSetInt</a>
<a href="Belt_MutableSetString.html">Belt_MutableSetString</a>
<a href="Belt_MutableStack.html">Belt_MutableStack</a>
<a href="Belt_Option.html">Belt_Option</a>
<a href="Belt_Range.html">Belt_Range</a>
<a href="Belt_Set.html">Belt_Set</a>
<a href="Belt_SetDict.html">Belt_SetDict</a>
<a href="Belt_SetInt.html">Belt_SetInt</a>
<a href="Belt_SetString.html">Belt_SetString</a>
<a href="Belt_SortArray.html">Belt_SortArray</a>
<a href="Belt_SortArrayInt.html">Belt_SortArrayInt</a>
<a href="Belt_SortArrayString.html">Belt_SortArrayString</a>
<a href="Dom.html">Dom</a>
<a href="Dom_storage.html">Dom_storage</a>
<a href="Js_array.html">Js_array</a>
<a href="Js_boolean.html">Js_boolean</a>
<a href="Js_cast.html">Js_cast</a>
<a href="Js_console.html">Js_console</a>
<a href="Js_date.html">Js_date</a>
<a href="Js_dict.html">Js_dict</a>
<a href="Js_global.html">Js_global</a>
<a href="Js_json.html">Js_json</a>
<a href="Js_list.html">Js_list</a>
<a href="Js_mapperRt.html">Js_mapperRt</a>
<a href="Js_math.html">Js_math</a>
<a href="Js_null_undefined.html">Js_null_undefined</a>
<a href="Js_obj.html">Js_obj</a>
<a href="Js_option.html">Js_option</a>
<a href="Js_promise.html">Js_promise</a>
<a href="Js_re.html">Js_re</a>
<a href="Js_result.html">Js_result</a>
<a href="Js_string.html">Js_string</a>
<a href="Js_types.html">Js_types</a>
<a href="Js_vector.html">Js_vector</a>
<a href="Node.html">Node</a>
<a href="Node_buffer.html">Node_buffer</a>
<a href="Node_child_process.html">Node_child_process</a>
<a href="Node_fs.html">Node_fs</a>
<a href="Node_module.html">Node_module</a>
<a href="Node_path.html">Node_path</a>
<a href="Node_process.html">Node_process</a></div>
    </div>
    </div>
  
    <div class='main'>
    <a href="https://github.com/bucklescript/bucklescript/blob/master/jscomp/stdlib/list.ml" class="edit-link">Edit</a>
    <p>List operations.</p>
<p>Some functions are flagged as not tail-recursive. A tail-recursive function uses constant stack space, while a non-tail-recursive function uses stack space proportional to the length of its list argument, which can be a problem with very long lists. When the function takes several list arguments, an approximate formula giving stack usage (in some unspecified constant unit) is shown in parentheses.</p>
<p>The above considerations can usually be ignored if your lists are not longer than about 10000 elements.</p>
<p>other items defined</p><div class='doc-item'><h4 class='item'>let <a href="#value-length" id="value-length">length</a>: list('a) => int</h4>

<div class='body '><p>Return the length (number of elements) of the given list.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-hd" id="value-hd">hd</a>: list('a) => 'a</h4>

<div class='body '><p>Return the first element of the given list. Raise <code>Failure &quot;hd&quot;</code> if the list is empty.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-tl" id="value-tl">tl</a>: list('a) => list('a)</h4>

<div class='body '><p>Return the given list without its first element. Raise <code>Failure &quot;tl&quot;</code> if the list is empty.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-nth" id="value-nth">nth</a>: (list('a), int) => 'a</h4>

<div class='body '><p>Return the <code>n</code>-th element of the given list. The first element (head of the list) is at position 0. Raise <code>Failure &quot;nth&quot;</code> if the list is too short. Raise <code>Invalid_argument &quot;List.nth&quot;</code> if <code>n</code> is negative.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-rev" id="value-rev">rev</a>: list('a) => list('a)</h4>

<div class='body '><p>List reversal.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-append" id="value-append">append</a>: (list('a), list('a)) => list('a)</h4>

<div class='body '><p>Catenate two lists. Same function as the infix operator <code>@</code>. Not tail-recursive (length of the first argument). The <code>@</code> operator is not tail-recursive either.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-rev_append" id="value-rev_append">rev_append</a>: (list('a), list('a)) => list('a)</h4>

<div class='body '><p><code>List.rev_append l1 l2</code> reverses <code>l1</code> and concatenates it to <code>l2</code>. This is equivalent to rev<code> l1 @ l2</code>, but <code>rev_append</code> is tail-recursive and more efficient.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-concat" id="value-concat">concat</a>: list(list('a)) => list('a)</h4>

<div class='body '><p>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-flatten" id="value-flatten">flatten</a>: list(list('a)) => list('a)</h4>

<div class='body '><p>Same as <code>concat</code>. Not tail-recursive (length of the argument + length of the longest sub-list).</p>
</div></div>

<div class='doc-item'><h4 id="Iterators">Iterators</h4></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-iter" id="value-iter">iter</a>: ('a => unit, list('a)) => unit</h4>

<div class='body '><p><code>List.iter f [a1; ...; an]</code> applies function <code>f</code> in turn to <code>a1; ...; an</code>. It is equivalent to <code>begin f a1; f a2; ...; f an; () end</code>.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-iteri" id="value-iteri">iteri</a>: ((int, 'a) => unit, list('a)) => unit</h4>

<div class='body '><p>Same as iter, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p>
Since: 4.00.0</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-map" id="value-map">map</a>: ('a => 'b, list('a)) => list('b)</h4>

<div class='body '><p><code>List.map f [a1; ...; an]</code> applies function <code>f</code> to <code>a1, ..., an</code>, and builds the list <code>[f a1; ...; f an]</code> with the results returned by <code>f</code>. Not tail-recursive.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-mapi" id="value-mapi">mapi</a>: ((int, 'a) => 'b, list('a)) => list('b)</h4>

<div class='body '><p>Same as map, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument. Not tail-recursive.</p>
Since: 4.00.0</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-rev_map" id="value-rev_map">rev_map</a>: ('a => 'b, list('a)) => list('b)</h4>

<div class='body '><p><code>List.rev_map f l</code> gives the same result as rev<code> (</code>map<code> f l)</code>, but is tail-recursive and more efficient.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-fold_left" id="value-fold_left">fold_left</a>: (('a, 'b) => 'a, 'a, list('b)) => 'a</h4>

<div class='body '><p><code>List.fold_left f a [b1; ...; bn]</code> is <code>f (... (f (f a b1) b2) ...) bn</code>.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-fold_right" id="value-fold_right">fold_right</a>: (('a, 'b) => 'b, list('a), 'b) => 'b</h4>

<div class='body '><p><code>List.fold_right f [a1; ...; an] b</code> is <code>f a1 (f a2 (... (f an b) ...))</code>. Not tail-recursive.</p>
</div></div>

<div class='doc-item'><h4 id="Iterators-on-two-lists">Iterators on two lists</h4></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-iter2" id="value-iter2">iter2</a>: (('a, 'b) => unit, list('a), list('b)) => unit</h4>

<div class='body '><p><code>List.iter2 f [a1; ...; an] [b1; ...; bn]</code> calls in turn <code>f a1 b1; ...; f an bn</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-map2" id="value-map2">map2</a>: (('a, 'b) => 'c, list('a), list('b)) => list('c)</h4>

<div class='body '><p><code>List.map2 f [a1; ...; an] [b1; ...; bn]</code> is <code>[f a1 b1; ...; f an bn]</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-rev_map2" id="value-rev_map2">rev_map2</a>: (('a, 'b) => 'c, list('a), list('b)) => list(
  'c
)</h4>

<div class='body '><p><code>List.rev_map2 f l1 l2</code> gives the same result as rev<code> (</code>map2<code> f l1 l2)</code>, but is tail-recursive and more efficient.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-fold_left2" id="value-fold_left2">fold_left2</a>: (
  ('a, 'b, 'c) => 'a,
  'a,
  list('b),
  list('c)
) => 'a</h4>

<div class='body '><p><code>List.fold_left2 f a [b1; ...; bn] [c1; ...; cn]</code> is <code>f (... (f (f a b1 c1) b2 c2) ...) bn cn</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-fold_right2" id="value-fold_right2">fold_right2</a>: (
  ('a, 'b, 'c) => 'c,
  list('a),
  list('b),
  'c
) => 'c</h4>

<div class='body '><p><code>List.fold_right2 f [a1; ...; an] [b1; ...; bn] c</code> is <code>f a1 b1 (f a2 b2 (... (f an bn c) ...))</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</p>
</div></div>

<div class='doc-item'><h4 id="List-scanning">List scanning</h4></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-for_all" id="value-for_all">for_all</a>: ('a => bool, list('a)) => bool</h4>

<div class='body '><p><code>for_all p [a1; ...; an]</code> checks if all elements of the list satisfy the predicate <code>p</code>. That is, it returns <code>(p a1) &amp;&amp; (p a2) &amp;&amp; ... &amp;&amp; (p an)</code>.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-exists" id="value-exists">exists</a>: ('a => bool, list('a)) => bool</h4>

<div class='body '><p><code>exists p [a1; ...; an]</code> checks if at least one element of the list satisfies the predicate <code>p</code>. That is, it returns <code>(p a1) || (p a2) || ... || (p an)</code>.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-for_all2" id="value-for_all2">for_all2</a>: (('a, 'b) => bool, list('a), list('b)) => bool</h4>

<div class='body '><p>Same as for_all, but for a two-argument predicate. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-exists2" id="value-exists2">exists2</a>: (('a, 'b) => bool, list('a), list('b)) => bool</h4>

<div class='body '><p>Same as exists, but for a two-argument predicate. Raise <code>Invalid_argument</code> if the two lists have different lengths.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-mem" id="value-mem">mem</a>: ('a, list('a)) => bool</h4>

<div class='body '><p><code>mem a l</code> is true if and only if <code>a</code> is equal to an element of <code>l</code>.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-memq" id="value-memq">memq</a>: ('a, list('a)) => bool</h4>

<div class='body '><p>Same as mem, but uses physical equality instead of structural equality to compare list elements.</p>
</div></div>

<div class='doc-item'><h4 id="List-searching">List searching</h4></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-find" id="value-find">find</a>: ('a => bool, list('a)) => 'a</h4>

<div class='body '><p><code>find p l</code> returns the first element of the list <code>l</code> that satisfies the predicate <code>p</code>. Raise <code>Not_found</code> if there is no value that satisfies <code>p</code> in the list <code>l</code>.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-filter" id="value-filter">filter</a>: ('a => bool, list('a)) => list('a)</h4>

<div class='body '><p><code>filter p l</code> returns all the elements of the list <code>l</code> that satisfy the predicate <code>p</code>. The order of the elements in the input list is preserved.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-find_all" id="value-find_all">find_all</a>: ('a => bool, list('a)) => list('a)</h4>

<div class='body '><p><code>find_all</code> is another name for filter.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-partition" id="value-partition">partition</a>: ('a => bool, list('a)) => (
  list('a),
  list('a)
)</h4>

<div class='body '><p><code>partition p l</code> returns a pair of lists <code>(l1, l2)</code>, where <code>l1</code> is the list of all the elements of <code>l</code> that satisfy the predicate <code>p</code>, and <code>l2</code> is the list of all the elements of <code>l</code> that do not satisfy <code>p</code>. The order of the elements in the input list is preserved.</p>
</div></div>

<div class='doc-item'><h4 id="Association-lists">Association lists</h4></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-assoc" id="value-assoc">assoc</a>: ('a, list(('a, 'b))) => 'b</h4>

<div class='body '><p><code>assoc a l</code> returns the value associated with key <code>a</code> in the list of pairs <code>l</code>. That is, <code>assoc a [ ...; (a,b); ...] = b</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>. Raise <code>Not_found</code> if there is no value associated with <code>a</code> in the list <code>l</code>.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-assq" id="value-assq">assq</a>: ('a, list(('a, 'b))) => 'b</h4>

<div class='body '><p>Same as assoc, but uses physical equality instead of structural equality to compare keys.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-mem_assoc" id="value-mem_assoc">mem_assoc</a>: ('a, list(('a, 'b))) => bool</h4>

<div class='body '><p>Same as assoc, but simply return true if a binding exists, and false if no bindings exist for the given key.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-mem_assq" id="value-mem_assq">mem_assq</a>: ('a, list(('a, 'b))) => bool</h4>

<div class='body '><p>Same as mem_assoc, but uses physical equality instead of structural equality to compare keys.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-remove_assoc" id="value-remove_assoc">remove_assoc</a>: ('a, list(('a, 'b))) => list(('a, 'b))</h4>

<div class='body '><p><code>remove_assoc a l</code> returns the list of pairs <code>l</code> without the first pair with key <code>a</code>, if any. Not tail-recursive.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-remove_assq" id="value-remove_assq">remove_assq</a>: ('a, list(('a, 'b))) => list(('a, 'b))</h4>

<div class='body '><p>Same as remove_assoc, but uses physical equality instead of structural equality to compare keys. Not tail-recursive.</p>
</div></div>

<div class='doc-item'><h4 id="Lists-of-pairs">Lists of pairs</h4></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-split" id="value-split">split</a>: list(('a, 'b)) => (list('a), list('b))</h4>

<div class='body '><p>Transform a list of pairs into a pair of lists: <code>split [(a1,b1); ...; (an,bn)]</code> is <code>([a1; ...; an], [b1; ...; bn])</code>. Not tail-recursive.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-combine" id="value-combine">combine</a>: (list('a), list('b)) => list(('a, 'b))</h4>

<div class='body '><p>Transform a pair of lists into a list of pairs: <code>combine [a1; ...; an] [b1; ...; bn]</code> is <code>[(a1,b1); ...; (an,bn)]</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</p>
</div></div>

<div class='doc-item'><h4 id="Sorting">Sorting</h4></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-sort" id="value-sort">sort</a>: (('a, 'a) => int, list('a)) => list('a)</h4>

<div class='body '><p>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, compare is a suitable comparison function. The resulting list is sorted in increasing order. <code>List.sort</code> is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</p>
<p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-stable_sort" id="value-stable_sort">stable_sort</a>: (('a, 'a) => int, list('a)) => list('a)</h4>

<div class='body '><p>Same as sort, but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order) .</p>
<p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-fast_sort" id="value-fast_sort">fast_sort</a>: (('a, 'a) => int, list('a)) => list('a)</h4>

<div class='body '><p>Same as sort or stable_sort, whichever is faster on typical input.</p>
</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-sort_uniq" id="value-sort_uniq">sort_uniq</a>: (('a, 'a) => int, list('a)) => list('a)</h4>

<div class='body '><p>Same as sort, but also remove duplicates.</p>
Since: 4.02.0</div></div>

<div class='doc-item'><h4 class='item'>let <a href="#value-merge" id="value-merge">merge</a>: (('a, 'a) => int, list('a), list('a)) => list('a)</h4>

<div class='body '><p>Merge two lists: Assuming that <code>l1</code> and <code>l2</code> are sorted according to the comparison function <code>cmp</code>, <code>merge cmp l1 l2</code> will return a sorted list containting all the elements of <code>l1</code> and <code>l2</code>. If several elements compare equal, the elements of <code>l1</code> will be before the elements of <code>l2</code>. Not tail-recursive (sum of the lengths of the arguments).</p>
</div></div>
    </div>
    <div class='right-blank'></div>
    </div>
  